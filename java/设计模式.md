# 设计模式

![image-20220309154641744](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309154641744.png)

## 一、OOP原则

![image-20220309124637815](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309124637815.png)

#### 1、开闭原则

> 对扩展开放，对修改关闭。
>
> > 新加的程序不应影响原来功能，可以扩展新的东西。

#### 2、里氏替换原则

> 继承必须确保超类所拥有的性质在子类中仍然成立。
>
> > 子类继承父类后可以扩展功能，尽量不要改动父类原有的功能 。

#### 3、依赖倒置原则

> 要面向接口编程，不要面向实现编程。
>
> > 面向接口编程，降低程序之间耦合性

#### 4、单一职责原则

> 控制类的粒度大小、将对象解耦、提高其内聚性
>
> > 一个方法尽量做一件事

#### 5、接口隔离原则

> 要为各个类建立他们需要的专用接口

#### 6、迪米特法则

> 只与你的直接朋友交谈，不跟“陌生人”说话。
>
> > A类和B类关联，B类和C类关联。
> >
> > 尽量不要A类和C类直接通信，而是通过中间类的方式

#### 7、合成复用原则

> 尽量先使用组合或者内聚合等关联关系来实现，其次才考虑使用继承关系来实现。
>
> > 使用继承关系时要满足**里氏替换原则**



## 二、单例模式

### 1、单例模式

#### 1.1饿汉式单例

```java
package com.basics.gof.single;

/**
 * @Description: 饿汉式单例
 * @author: ningningyu
 * @since: 2022/03/08
 */
public class Hungry {

    //类加载的时候就加载，可能会浪费空间
    private byte[] data1 = new byte[1024 * 1024];
    private byte[] data2 = new byte[1024 * 1024];
    private byte[] data3 = new byte[1024 * 1024];
    private byte[] data4 = new byte[1024 * 1024];


    private Hungry() {

    }

    private final static Hungry HUNGRY = new Hungry();

    public static Hungry getInstance() {
        return HUNGRY;
    }
    
}

```

#### 1.2懒汉式单例

##### 1.2.1 单线程单例

```java
package com.basics.gof.single;

/**
 * @Description: 懒汉式单例
 * @author: ningningyu
 * @since: 2022/03/08
 */
public class LazyMan {

    private LazyMan() {

    }

    private static LazyMan lazyMan;

    public static LazyMan getInstance() {
        if (lazyMan == null) {
            lazyMan = new LazyMan();
        }
        return lazyMan;
    }

}
```



##### 1.2.2 单线程单例在多线程下会出现问题

![image-20220308154547443](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220308154547443.png)



##### 1.2.3 双重检测锁模式&DCL懒汉式-解决1.2.2多线程问题

![image-20220308155207410](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220308155207410.png)



##### 1.2.4 双重检测锁模式&DCL懒汉式存在的问题

![image-20220308160620184](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220308160620184.png)

> 代码

```java
package com.basics.gof.single;

/**
 * @Description: 懒汉式单例
 * @author: ningningyu
 * @since: 2022/03/08
 */
public class LazyMan {

    private LazyMan() {
        System.out.println(Thread.currentThread().getName());
    }

    private volatile static LazyMan lazyMan;

    //双重检测锁模式 DCL懒汉式
    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();//不是原子操作
                    /**
                     * 正常步骤：
                     * 1.分配内存空间
                     * 2.执行构造方法，初始化对象
                     * 3.把这个对象指向这个空间
                     *
                     * 异常分析：指令重排
                     * A线程操作步骤为1.3.2
                     * 此时在A操作到3的时候，有B线程来了。他在此时判断lazyMan不是null，就会立刻return lazyMan;
                     * 但是此时lazyMan没有完成构造
                     */

                }
            }
        }
        return lazyMan;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                LazyMan.getInstance();
            }).start();
        }
    }

}

```



##### 1.2.5 使用反射破坏1.2.4单例

![image-20220309125205534](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309125205534.png)



##### 1.2.6 防止1.2.5对单例的破坏

![image-20220308163415408](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220308163415408.png)



##### 1.2.7 再次对1.2.6进行破坏

![](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/1.2.7.png)



##### 1.2.8 使用外部标志位防止对1.2.7对1.2.6进行破坏

![image-20220308180747972](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220308180747972.png)



##### 1.2.9 再次对1.2.8进行破坏

![image-20220308205454987](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220308205454987.png)

##### 1.2.10 完整代码

```java
package com.basics.gof.single;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;

/**
 * @Description: 懒汉式单例
 * @author: ningningyu
 * @since: 2022/03/08
 */
public class LazyMan {

    private static boolean flag = false;

    private LazyMan() {
        synchronized (LazyMan.class) {
            if (!flag) {
                flag = true;
            } else {
                throw new RuntimeException("不要试图使用反射破坏");
            }
        }
    }

    private volatile static LazyMan lazyMan;

    //双重检测锁模式 DCL懒汉式
    public static LazyMan getInstance() {
        if (lazyMan == null) {
            synchronized (LazyMan.class) {
                if (lazyMan == null) {
                    lazyMan = new LazyMan();//不是原子操作
                    /**
                     * 正常步骤：
                     * 1.分配内存空间
                     * 2.执行构造方法，初始化对象
                     * 3.把这个对象指向这个空间
                     *
                     * 异常分析：指令重排
                     * A线程操作步骤为1.3.2
                     * 此时在A操作到3的时候，有B线程来了。他在此时判断lazyMan不是null，就会立刻return lazyMan;
                     * 但是此时lazyMan没有完成构造
                     */

                }
            }
        }
        return lazyMan;
    }

    //反射
    public static void main(String[] args) throws Exception {
        //外部标志位
        Field flag = LazyMan.class.getDeclaredField("flag");
        flag.setAccessible(true);

        Constructor<LazyMan> declaredConstructor = LazyMan.class.getDeclaredConstructor(null);
        declaredConstructor.setAccessible(true);
        LazyMan instance = declaredConstructor.newInstance();

        flag.set(instance, false);

        LazyMan instance2 = declaredConstructor.newInstance();

        System.out.println(instance);
        System.out.println(instance2);


    }

}

```





#### 1.3静态内部类单例

```java
package com.basics.gof.single;

/**
 * @Description: 静态内部类实现单例
 * @author: ningningyu
 * @since: 2022/03/08
 */
public class Holder {

    private Holder() {

    }

    public static Holder getInstance() {
        return InnerClass.HOLDER;
    }

    public static class InnerClass {
        private static final Holder HOLDER = new Holder();
    }

}

```



#### 1.4GetInstance与new区别

###### new的使用

如Objec object = new Object()，这时候，就必须要知道有第二个Object的存在，而第二个Object也常常是在当前的应用程序域中的，可以被直接调用的

###### GetInstance的使用

在主函数开始时调用，返回一个实例化对象，此对象是static的，在内存中保留着它的引用，即内存中有一块区域专门用来存放静态方法和变量，可以直接使用，调用多次返回同一个对象。



## 三、工厂模式

![image-20220309153901203](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309153901203.png)

### 1、简单工厂

#### 1.1 原始方式实现简单工厂

<img src="https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309152115838.png" alt="image-20220309152115838" style="zoom: 50%;" />

```java
package com.basics.gof.factory.simple;

/**
 * @Description: TODO
 * @author: ningningyu
 * @since: 2022/03/09
 */
public interface Car {
    void carName();
}

```

```java
package com.basics.gof.factory.simple;

/**
 * @Description: 特斯拉
 * @author: ningningyu
 * @since: 2022/03/09
 */
public class TeslaCar implements Car {
    @Override
    public void carName() {
        System.out.println("我是特斯拉！");
    }
}

```

```java
package com.basics.gof.factory.simple;

/**
 * @Description: 五菱车
 * @author: ningningyu
 * @since: 2022/03/09
 */
public class WuLingCar implements Car{
    @Override
    public void carName() {
        System.out.println("我是五菱神车！");
    }
}

```

```java
package com.basics.gof.factory.simple;

/**
 * @Description: TODO
 * @author: ningningyu
 * @since: 2022/03/09
 */
public class Consumer {
    public static void main(String[] args) {
        Car wuLing = new WuLingCar();
        Car tesla = new TeslaCar();

        wuLing.carName();
        tesla.carName();
    }
}

```

![image-20220309150516683](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309150516683.png)



#### 1.2 使用工厂类实现简单工厂

在1.1代码的基础上改动

<img src="https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309152220096.png" alt="image-20220309152220096" style="zoom:50%;" />

```java
package com.basics.gof.factory.simple;

/**
 * @Description: TODO
 * @author: ningningyu
 * @since: 2022/03/09
 */
public class CarFactory {
    //方法一
    public static Car getCar(String carName) {
        if ("五菱".equals(carName)) {
            return new WuLingCar();
        } else if ("特斯拉".equals(carName)) {
            return new TeslaCar();
        } else {
            return null;
        }
    }

    //方法二
    public static Car getWuLing() {
        return new WuLingCar();
    }
    public static Car getTesla() {
        return new TeslaCar();
    }


}

```

<img src="https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309151837433.png" alt="image-20220309151837433" />



### 2、工厂方法模式

![image-20220309153933949](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309153933949.png)

车类和车工厂类：

```java
package com.basics.gof.factory.factoryMethod;

/**
 * @Description: TODO
 * @author: ningningyu
 * @since: 2022/03/09
 */
public interface Car {
    void carName();
}

```

```java
package com.basics.gof.factory.factoryMethod;

/**
 * @Description: TODO
 * @author: ningningyu
 * @since: 2022/03/09
 */
public interface CarFactory {
    Car getCar();
}

```

特斯拉类和特斯拉工厂类：

```java
package com.basics.gof.factory.factoryMethod;

/**
 * @Description: 特斯拉
 * @author: ningningyu
 * @since: 2022/03/09
 */
public class TeslaCar implements Car {
    @Override
    public void carName() {
        System.out.println("我是特斯拉！");
    }
}

```

```java
package com.basics.gof.factory.factoryMethod;

/**
 * @Description: 特斯拉
 * @author: ningningyu
 * @since: 2022/03/09
 */
public class TeslaFactory implements CarFactory {

    @Override
    public Car getCar() {
        return new TeslaCar();
    }
}

```

五菱类和五菱工厂类：

```java
package com.basics.gof.factory.factoryMethod;

/**
 * @Description: 五菱车
 * @author: ningningyu
 * @since: 2022/03/09
 */
public class WuLingCar implements Car {
    @Override
    public void carName() {
        System.out.println("我是五菱神车！");
    }
}

```

```java
package com.basics.gof.factory.factoryMethod;

/**
 * @Description: 五菱车
 * @author: ningningyu
 * @since: 2022/03/09
 */
public class WuLingFactory implements CarFactory {

    @Override
    public Car getCar() {
        return new WuLingCar();
    }
}

```

消费者：

```java
package com.basics.gof.factory.factoryMethod;

/**
 * @Description: TODO
 * @author: ningningyu
 * @since: 2022/03/09
 */
public class Consumer {
    public static void main(String[] args) {
        WuLingFactory wuLingFactory = new WuLingFactory();
        TeslaFactory teslaFactory = new TeslaFactory();

        wuLingFactory.getCar().carName();
        teslaFactory.getCar().carName();

    }
}

```

**优点：后续再增加其它的车，只需要创建新的工厂类即可。无需改动原有代码；符合开闭原则**



### 3、简单工厂和工厂方法模式对比

|     对比方式     | 简单工厂模式 | 工厂方法模式 |
| :--------------: | :----------: | :----------: |
|    结构复杂度    |      胜      |              |
|    代码复杂度    |      胜      |              |
|    编程复杂度    |      胜      |              |
|    管理复杂度    |      胜      |              |
| 根据设计模式原则 |              |      胜      |
|   根据实际业务   |      胜      |              |

![image-20220309154723055](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309154723055.png)

## 四、建造者模式

![image-20220309203902578](https://gitee.com/jeffreyu/drawing-bed-gitee/raw/master/Img/image-20220309203902578.png)

### 1、第一种























































